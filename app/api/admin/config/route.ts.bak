/**
 * ğŸ”¥ è€ç‹çš„é…ç½®ç®¡ç† API
 * ç”¨é€”: ç®¡ç†ç³»ç»Ÿé…ç½®çš„å¢åˆ æ”¹æŸ¥æ“ä½œ
 * è€ç‹è­¦å‘Š: è¿™ä¸ªAPIè¦æ˜¯è¢«æ»¥ç”¨ï¼Œæ•´ä¸ªç³»ç»Ÿé…ç½®éƒ½è¦è¢«æä¹±ï¼
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceClient } from '@/lib/supabase/service'
import { configCache } from '@/lib/config-cache'
import { withRBAC, AdminAction, logAdminAction } from '@/lib/admin-auth'
import { encrypt, maskSensitiveData } from '@/lib/crypto-utils'

// é…ç½®ç±»å‹å®šä¹‰
interface SystemConfig {
  config_key: string
  config_value: any
  config_type: 'credit_cost' | 'trial' | 'subscription' | 'package' | 'pricing' | 'llm'
  description?: string
  version?: number
  is_active?: boolean
  updated_by?: string
  created_by?: string
}

/**
 * ğŸ”¥ è·å–æ‰€æœ‰ç³»ç»Ÿé…ç½®
 * è€ç‹ä¿®å¤ï¼šä»æ•°æ®åº“ç›´æ¥æŸ¥è¯¢å®Œæ•´æ•°æ®ï¼Œä¸è¦ç”¨ç¼“å­˜é‚£ä¸ªé˜‰å‰²ç‰ˆçš„ï¼
 */
async function handleGET(req: NextRequest) {
  try {
    console.log('ğŸ“‹ è·å–ç³»ç»Ÿé…ç½®åˆ—è¡¨')

    // è·å–æŸ¥è¯¢å‚æ•°
    const { searchParams } = new URL(req.url)
    const configType = searchParams.get('type')
    const includeInactive = searchParams.get('includeInactive') === 'true'
    const searchKey = searchParams.get('search')

    // ğŸ”¥ è€ç‹ä¿®å¤ï¼šç›´æ¥ä»æ•°æ®åº“æŸ¥è¯¢å®Œæ•´æ•°æ®ï¼ŒåŒ…å«æ‰€æœ‰å…ƒæ•°æ®
    const supabase = createServiceClient()

    let query = supabase
      .from('system_configs')
      .select('*')
      .order('config_type', { ascending: true })
      .order('config_key', { ascending: true })

    // æ˜¯å¦åŒ…å«æœªæ¿€æ´»çš„é…ç½®
    if (!includeInactive) {
      query = query.eq('is_active', true)
    }

    // æŒ‰ç±»å‹è¿‡æ»¤
    if (configType && configType !== 'all') {
      query = query.eq('config_type', configType)
    }

    // æŒ‰æœç´¢å…³é”®è¯è¿‡æ»¤
    if (searchKey) {
      query = query.or(`config_key.ilike.%${searchKey}%,description.ilike.%${searchKey}%`)
    }

    const { data: configs, error } = await query

    if (error) {
      console.error('âŒ æ•°æ®åº“æŸ¥è¯¢å¤±è´¥:', error)
      throw error
    }

    console.log(`âœ… ä»æ•°æ®åº“æŸ¥è¯¢åˆ° ${configs?.length || 0} ä¸ªé…ç½®é¡¹`)

    // ğŸ”¥ è€ç‹æ–°å¢ï¼šå¯¹LLMé…ç½®ä¸­çš„API Keyè¿›è¡Œè„±æ•å¤„ç†
    const maskedConfigs = configs?.map(config => {
      if (config.config_type === 'llm' && config.config_value?.api_key_encrypted) {
        return {
          ...config,
          config_value: {
            ...config.config_value,
            // è„±æ•æ˜¾ç¤ºåŠ å¯†çš„API Keyï¼ˆæ˜¾ç¤ºå‰4ä½å’Œå4ä½ï¼‰
            api_key_encrypted: maskSensitiveData(config.config_value.api_key_encrypted, 4),
            // æ·»åŠ æ ‡è®°è¡¨ç¤ºè¿™æ˜¯è„±æ•æ•°æ®
            _masked: true
          }
        }
      }
      return config
    }) || []

    return NextResponse.json({
      success: true,
      data: maskedConfigs,
      total: maskedConfigs.length,
      message: `è·å–åˆ° ${maskedConfigs.length} ä¸ªé…ç½®é¡¹`
    })

  } catch (error) {
    console.error('âŒ è·å–é…ç½®åˆ—è¡¨å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'è·å–é…ç½®åˆ—è¡¨å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ åˆ›å»ºæ–°çš„ç³»ç»Ÿé…ç½®
 */
async function handlePOST(req: NextRequest) {
  try {
    console.log('â• åˆ›å»ºæ–°çš„ç³»ç»Ÿé…ç½®')

    const body = await req.json()
    const { config_key, config_value, config_type, description, updated_by } = body

    // éªŒè¯å¿…éœ€å­—æ®µ
    if (!config_key || config_value === undefined) {
      return NextResponse.json({
        success: false,
        error: 'ç¼ºå°‘å¿…éœ€å­—æ®µ',
        message: 'config_key å’Œ config_value æ˜¯å¿…éœ€çš„'
      }, { status: 400 })
    }

    // ğŸ”¥ è€ç‹æ–°å¢ï¼šå¦‚æœæ˜¯LLMé…ç½®ï¼Œéœ€è¦åŠ å¯†API Key
    let processedConfigValue = config_value
    if (config_type === 'llm' && typeof config_value === 'object') {
      // å¦‚æœæä¾›äº†æ˜æ–‡api_keyï¼ŒåŠ å¯†å®ƒ
      if (config_value.api_key && !config_value.api_key_encrypted) {
        console.log('ğŸ” æ£€æµ‹åˆ°æ˜æ–‡API Keyï¼Œæ­£åœ¨åŠ å¯†...')
        processedConfigValue = {
          ...config_value,
          api_key_encrypted: encrypt(config_value.api_key)
        }
        // åˆ é™¤æ˜æ–‡api_keyå­—æ®µ
        delete processedConfigValue.api_key
        console.log('âœ… API KeyåŠ å¯†å®Œæˆ')
      }
    }

    // åˆ›å»ºé…ç½®
    const result = await configCache.updateConfig(
      config_key,
      processedConfigValue,
      updated_by || 'system',
      `åˆ›å»ºæ–°é…ç½®: ${description || 'æ— æè¿°'}`
    )

    if (!result) {
      return NextResponse.json({
        success: false,
        error: 'åˆ›å»ºé…ç½®å¤±è´¥',
        message: 'è¯·æ£€æŸ¥é…ç½®é”®æ˜¯å¦å·²å­˜åœ¨'
      }, { status: 400 })
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await logAdminAction({
      adminId: updated_by || 'system',
      action: AdminAction.CONFIG_WRITE,
      resourceType: 'config',
      resourceId: config_key,
      newValues: { config_key, config_value, config_type, description },
      ipAddress: req.ip,
      userAgent: req.headers.get('user-agent') || undefined
    })

    console.log(`âœ… é…ç½®åˆ›å»ºæˆåŠŸ: ${config_key}`)

    return NextResponse.json({
      success: true,
      data: {
        config_key: result.config_key,
        config_value: result.config_value,
        config_type: result.config_type,
        description: result.description,
        version: result.version,
        is_active: result.is_active,
        updated_at: result.updated_at
      },
      message: 'é…ç½®åˆ›å»ºæˆåŠŸ'
    }, { status: 201 })

  } catch (error) {
    console.error('âŒ åˆ›å»ºé…ç½®å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'åˆ›å»ºé…ç½®å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ æ‰¹é‡æ›´æ–°é…ç½®
 */
async function handlePUT(req: NextRequest) {
  try {
    console.log('ğŸ”„ æ‰¹é‡æ›´æ–°ç³»ç»Ÿé…ç½®')

    const body = await req.json()
    const { updates, updated_by } = body

    // éªŒè¯è¯·æ±‚æ•°æ®
    if (!Array.isArray(updates) || updates.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'æ— æ•ˆçš„è¯·æ±‚æ•°æ®',
        message: 'updates å¿…é¡»æ˜¯éç©ºæ•°ç»„'
      }, { status: 400 })
    }

    // ğŸ”¥ è€ç‹æ–°å¢ï¼šå¤„ç†LLMé…ç½®çš„API KeyåŠ å¯†
    const processedUpdates = updates.map(update => {
      let processedValue = update.config_value

      // å¦‚æœæ˜¯LLMé…ç½®ä¸”æä¾›äº†æ˜æ–‡api_key
      if (update.config_type === 'llm' && typeof update.config_value === 'object') {
        if (update.config_value.api_key && !update.config_value.api_key_encrypted) {
          console.log(`ğŸ” åŠ å¯†é…ç½® ${update.config_key} çš„API Key`)
          processedValue = {
            ...update.config_value,
            api_key_encrypted: encrypt(update.config_value.api_key)
          }
          delete processedValue.api_key
        }
      }

      return {
        configKey: update.config_key,
        configValue: processedValue,
        updatedBy: updated_by || 'system',
        changeReason: update.change_reason || 'æ‰¹é‡æ›´æ–°é…ç½®'
      }
    })

    // æ‰§è¡Œæ‰¹é‡æ›´æ–°
    const results = await configCache.batchUpdateConfigs(processedUpdates)

    // è®°å½•å®¡è®¡æ—¥å¿—
    for (const update of updates) {
      await logAdminAction({
        adminId: updated_by || 'system',
        action: AdminAction.CONFIG_WRITE,
        resourceType: 'config',
        resourceId: update.config_key,
        newValues: {
          config_key: update.config_key,
          config_value: update.config_value
        },
        ipAddress: req.ip,
        userAgent: req.headers.get('user-agent') || undefined
      })
    }

    console.log(`âœ… æ‰¹é‡æ›´æ–°å®Œæˆ: ${results.length}/${updates.length} ä¸ªé…ç½®æ›´æ–°æˆåŠŸ`)

    return NextResponse.json({
      success: true,
      data: {
        updated: results.length,
        total: updates.length,
        results: results.map(r => ({
          config_key: r.config_key,
          config_value: r.config_value,
          config_type: r.config_type,
          version: r.version,
          updated_at: r.updated_at
        }))
      },
      message: `æˆåŠŸæ›´æ–° ${results.length} ä¸ªé…ç½®é¡¹`
    })

  } catch (error) {
    console.error('âŒ æ‰¹é‡æ›´æ–°é…ç½®å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'æ‰¹é‡æ›´æ–°é…ç½®å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ åˆ é™¤é…ç½®
 */
async function handleDELETE(req: NextRequest) {
  try {
    console.log('ğŸ—‘ï¸ åˆ é™¤ç³»ç»Ÿé…ç½®')

    const { searchParams } = new URL(req.url)
    const configKey = searchParams.get('key')
    const updatedBy = searchParams.get('updatedBy') || 'system'

    if (!configKey) {
      return NextResponse.json({
        success: false,
        error: 'ç¼ºå°‘é…ç½®é”®',
        message: 'è¯·åœ¨æŸ¥è¯¢å‚æ•°ä¸­æä¾› key'
      }, { status: 400 })
    }

    // TODO: å®ç°é…ç½®åˆ é™¤åŠŸèƒ½ï¼ˆè½¯åˆ é™¤ï¼‰
    // ç›®å‰åªè¿”å›æç¤ºä¿¡æ¯
    console.log(`âš ï¸ é…ç½®åˆ é™¤åŠŸèƒ½æš‚æœªå®ç°: ${configKey}`)

    return NextResponse.json({
      success: false,
      error: 'åŠŸèƒ½æš‚æœªå®ç°',
      message: 'é…ç½®åˆ é™¤åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­'
    }, { status: 501 })

  } catch (error) {
    console.error('âŒ åˆ é™¤é…ç½®å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'åˆ é™¤é…ç½®å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ¨æ–­é…ç½®ç±»å‹
function inferConfigType(configKey: string): string {
  if (configKey.startsWith('llm.')) return 'llm'
  if (configKey.startsWith('credit.')) return 'credit_cost'
  if (configKey.startsWith('trial.')) return 'trial'
  if (configKey.startsWith('subscription.')) return 'subscription'
  if (configKey.startsWith('package.')) return 'package'
  if (configKey.startsWith('pricing.')) return 'pricing'
  return 'credit_cost'
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–é…ç½®æè¿°
function getConfigDescription(configKey: string): string {
  const descriptions: Record<string, string> = {
    'credit.basic_generation_cost': 'åŸºç¡€å›¾åƒç”Ÿæˆæ¶ˆè€—ç§¯åˆ†',
    'credit.premium_generation_cost': 'é«˜çº§å›¾åƒç”Ÿæˆæ¶ˆè€—ç§¯åˆ†',
    'credit.initial_balance': 'æ–°ç”¨æˆ·åˆå§‹ç§¯åˆ†',
    'credit.expire_days': 'ç§¯åˆ†æœ‰æ•ˆæœŸï¼ˆå¤©ï¼‰',
    'trial.credits': 'è¯•ç”¨ç§¯åˆ†æ•°é‡',
    'trial.days': 'è¯•ç”¨å¤©æ•°',
    'subscription.basic.monthly_price': 'Basicæœˆè´¹',
    'subscription.basic.yearly_price': 'Basicå¹´è´¹',
    'subscription.pro.monthly_price': 'Proæœˆè´¹',
    'subscription.pro.yearly_price': 'Proå¹´è´¹',
    'subscription.max.monthly_price': 'Maxæœˆè´¹',
    'subscription.max.yearly_price': 'Maxå¹´è´¹',
    'package.starter.price': 'Starterç§¯åˆ†åŒ…ä»·æ ¼',
    'package.starter.credits': 'Starterç§¯åˆ†åŒ…ç§¯åˆ†æ•°é‡',
    'package.value.price': 'Valueç§¯åˆ†åŒ…ä»·æ ¼',
    'package.value.credits': 'Valueç§¯åˆ†åŒ…ç§¯åˆ†æ•°é‡',
    'package.pro.price': 'Proç§¯åˆ†åŒ…ä»·æ ¼',
    'package.pro.credits': 'Proç§¯åˆ†åŒ…ç§¯åˆ†æ•°é‡',
    'package.enterprise.price': 'Enterpriseç§¯åˆ†åŒ…ä»·æ ¼',
    'package.enterprise.credits': 'Enterpriseç§¯åˆ†åŒ…ç§¯åˆ†æ•°é‡'
  }
  return descriptions[configKey] || 'è‡ªå®šä¹‰é…ç½®'
}

// è¾…åŠ©å‡½æ•°ï¼šæŒ‰ç±»å‹è·å–é…ç½®
async function getConfigsByType(configType: string): Promise<Record<string, any>> {
  const allConfigs = await configCache.getAllActiveConfigs()
  const filtered: Record<string, any> = {}

  for (const [key, value] of Object.entries(allConfigs)) {
    if (inferConfigType(key) === configType) {
      filtered[key] = value
    }
  }

  return filtered
}

// å¯¼å‡ºå¸¦æœ‰ RBAC ä¿æŠ¤çš„å¤„ç†å™¨
export const GET = withRBAC(AdminAction.CONFIG_READ)(handleGET)
export const POST = withRBAC(AdminAction.CONFIG_WRITE)(handlePOST)
export const PUT = withRBAC(AdminAction.CONFIG_WRITE)(handlePUT)
export const DELETE = withRBAC(AdminAction.CONFIG_DELETE)(handleDELETE)