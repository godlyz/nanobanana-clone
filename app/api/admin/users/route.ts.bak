/**
 * ğŸ”¥ è€ç‹çš„ç®¡ç†å‘˜ç”¨æˆ·ç®¡ç† API
 * ç”¨é€”: ç®¡ç†å‘˜è´¦æˆ·çš„å¢åˆ æ”¹æŸ¥æ“ä½œ
 * è€ç‹è­¦å‘Š: è¿™ä¸ªAPIè¦æ˜¯è¢«é»‘å®¢æ”»ç ´ï¼Œæ•´ä¸ªç³»ç»Ÿéƒ½è¦å®Œè›‹ï¼
 */

import { NextRequest, NextResponse } from 'next/server'
import { createServiceClient } from '@/lib/supabase/service'
import { withRBAC, AdminAction, logAdminAction } from '@/lib/admin-auth'
import bcrypt from 'bcryptjs'
import { randomUUID } from 'crypto'

// ç®¡ç†å‘˜ç”¨æˆ·æ¥å£
interface AdminUser {
  id: string
  email: string
  name: string
  role: 'super_admin' | 'admin' | 'viewer'
  status: 'active' | 'inactive' | 'suspended'
  last_login?: string
  created_at: string
  updated_at: string
  created_by?: string
  updated_by?: string
}

/**
 * ğŸ”¥ è·å–ç®¡ç†å‘˜ç”¨æˆ·åˆ—è¡¨
 */
async function handleGET(req: NextRequest) {
  try {
    console.log('ğŸ“‹ è·å–ç®¡ç†å‘˜ç”¨æˆ·åˆ—è¡¨')

    // è·å–æŸ¥è¯¢å‚æ•°
    const { searchParams } = new URL(req.url)
    const search = searchParams.get('search')
    const role = searchParams.get('role')
    const status = searchParams.get('status')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '20')

    const supabase = createServiceClient()

    // æ„å»ºæŸ¥è¯¢
    let query = supabase
      .from('admin_users')
      .select('*')
      .order('created_at', { ascending: false })

    // åº”ç”¨è¿‡æ»¤æ¡ä»¶
    if (search) {
      const searchTerm = `%${search.toLowerCase()}%`
      query = query.or(`email.ilike.${searchTerm}`, `name.ilike.${searchTerm}`)
    }

    if (role && role !== 'all') {
      query = query.eq('role', role)
    }

    if (status && status !== 'all') {
      query = query.eq('status', status)
    }

    // åˆ†é¡µå¤„ç†
    const countQuery = query.select('*', { count: 'exact', head: true })
    const { count: totalCount } = await countQuery

    const from = (page - 1) * limit
    const to = from + limit - 1

    const { data: users, error } = await query.range(from, to)

    if (error) {
      console.error('âŒ è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥:', error)
      return NextResponse.json({
        success: false,
        error: 'è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥',
        message: error.message
      }, { status: 500 })
    }

    // æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedUsers = users.map(user => ({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
      status: user.status,
      last_login: user.last_login,
      created_at: user.created_at,
      updated_at: user.updated_at,
      created_by: user.created_by,
      updated_by: user.updated_by
    }))

    return NextResponse.json({
      success: true,
      data: formattedUsers,
      pagination: {
        page,
        limit,
        total: totalCount || 0,
        totalPages: Math.ceil((totalCount || 0) / limit),
        hasNext: page * limit < (totalCount || 0)
      },
      message: `è·å–åˆ° ${formattedUsers.length} ä¸ªç®¡ç†å‘˜ç”¨æˆ·`
    })

  } catch (error) {
    console.error('âŒ è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'è·å–ç®¡ç†å‘˜åˆ—è¡¨å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ åˆ›å»ºæ–°çš„ç®¡ç†å‘˜ç”¨æˆ·
 */
async function handlePOST(req: NextRequest) {
  try {
    console.log('â• åˆ›å»ºæ–°çš„ç®¡ç†å‘˜ç”¨æˆ·')

    const body = await req.json()
    const { email, name, password, role = 'admin', createdBy = 'system' } = body

    // éªŒè¯å¿…éœ€å­—æ®µ
    if (!email || !name || !password) {
      return NextResponse.json({
        success: false,
        error: 'ç¼ºå°‘å¿…éœ€å­—æ®µ',
        message: 'email, name, password æ˜¯å¿…éœ€çš„'
      }, { status: 400 })
    }

    // éªŒè¯é‚®ç®±æ ¼å¼
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return NextResponse.json({
        success: false,
        error: 'é‚®ç®±æ ¼å¼æ— æ•ˆ',
        message: 'è¯·æä¾›æœ‰æ•ˆçš„é‚®ç®±åœ°å€'
      }, { status: 400 })
    }

    // éªŒè¯å¯†ç å¼ºåº¦
    if (password.length < 8) {
      return NextResponse.json({
        success: false,
        error: 'å¯†ç å¼ºåº¦ä¸è¶³',
        message: 'å¯†ç é•¿åº¦è‡³å°‘ä¸º8ä½'
      }, { status: 400 })
    }

    const supabase = createServiceClient()

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    const { data: existingUser } = await supabase
      .from('admin_users')
      .select('email')
      .eq('email', email)
      .single()

    if (existingUser) {
      return NextResponse.json({
        success: false,
        error: 'é‚®ç®±å·²å­˜åœ¨',
        message: 'è¯¥é‚®ç®±åœ°å€å·²è¢«æ³¨å†Œ'
      }, { status: 400 })
    }

    // å¯†ç å“ˆå¸Œå¤„ç†
    const passwordHash = await bcrypt.hash(password, 12)

    // åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·
    const { data: newUser, error: createError } = await supabase
      .from('admin_users')
      .insert({
        email,
        name,
        role,
        status: 'active',
        password_hash: passwordHash,
        created_by: createdBy,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single()

    if (createError) {
      console.error('âŒ åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥:', createError)
      return NextResponse.json({
        success: false,
        error: 'åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥',
        message: createError.message
      }, { status: 500 })
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await logAdminAction({
      adminId: createdBy,
      action: AdminAction.USER_WRITE,
      resourceType: 'user',
      resourceId: newUser.id,
      newValues: {
        email,
        name,
        role,
        status: 'active'
      },
      ipAddress: req.ip,
      userAgent: req.headers.get('user-agent') || undefined
    })

    console.log(`âœ… ç®¡ç†å‘˜ç”¨æˆ·åˆ›å»ºæˆåŠŸ: ${email} (${role})`)

    return NextResponse.json({
      success: true,
      data: {
        id: newUser.id,
        email: newUser.email,
        name: newUser.name,
        role: newUser.role,
        status: newUser.status,
        created_at: newUser.created_at,
        created_by: newUser.created_by
      },
      message: 'ç®¡ç†å‘˜ç”¨æˆ·åˆ›å»ºæˆåŠŸ'
    }, { status: 201 })

  } catch (error) {
    console.error('âŒ åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·
 */
async function handlePUT(req: NextRequest) {
  try {
    console.log('ğŸ”„ æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·')

    const { searchParams } = new URL(req.url)
    const id = searchParams.get('id')
    const { status, role, name, updatedBy } = await req.json()

    if (!id) {
      return NextResponse.json({
        success: false,
        error: 'ç¼ºå°‘ç”¨æˆ·ID',
        message: 'è¯·åœ¨è·¯å¾„å‚æ•°ä¸­æä¾›ç”¨æˆ·ID'
      }, { status: 400 })
    }

    const supabase = createServiceClient()

    // è·å–åŸå§‹ç”¨æˆ·æ•°æ®
    const { data: originalUser, error: fetchError } = await supabase
      .from('admin_users')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !originalUser) {
      return NextResponse.json({
        success: false,
        error: 'ç”¨æˆ·ä¸å­˜åœ¨',
        message: 'æŒ‡å®šçš„ç”¨æˆ·ä¸å­˜åœ¨'
      }, { status: 404 })
    }

    // æ„å»ºæ›´æ–°æ•°æ®
    const updateData: any = {
      updated_at: new Date().toISOString(),
      updated_by: updatedBy || 'system'
    }

    if (status !== undefined) updateData.status = status
    if (role !== undefined) updateData.role = role
    if (name !== undefined) updateData.name = name

    // æ›´æ–°ç”¨æˆ·æ•°æ®
    const { data: updatedUser, error: updateError } = await supabase
      .from('admin_users')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (updateError) {
      console.error('âŒ æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥:', updateError)
      return NextResponse.json({
        success: false,
        error: 'æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥',
        message: updateError.message
      }, { status: 500 })
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await logAdminAction({
      adminId: updatedBy || 'system',
      action: AdminAction.USER_WRITE,
      resourceType: 'user',
      resourceId: id,
      oldValues: {
        status: originalUser.status,
        role: originalUser.role,
        name: originalUser.name
      },
      newValues: updateData,
      ipAddress: req.ip,
      userAgent: req.headers.get('user-agent') || undefined
    })

    console.log(`âœ… ç®¡ç†å‘˜ç”¨æˆ·æ›´æ–°æˆåŠŸ: ${originalUser.email}`)

    return NextResponse.json({
      success: true,
      data: {
        id: updatedUser.id,
        email: updatedUser.email,
        name: updatedUser.name,
        role: updatedUser.role,
        status: updatedUser.status,
        updated_at: updatedUser.updated_at,
        updated_by: updatedUser.updated_by
      },
      message: 'ç®¡ç†å‘˜ç”¨æˆ·æ›´æ–°æˆåŠŸ'
    })

  } catch (error) {
    console.error('âŒ æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'æ›´æ–°ç®¡ç†å‘˜ç”¨æˆ·å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

/**
 * ğŸ”¥ é‡ç½®ç®¡ç†å‘˜å¯†ç 
 */
async function handlePATCH(req: NextRequest) {
  try {
    console.log('ğŸ”’ é‡ç½®ç®¡ç†å‘˜å¯†ç ')

    const { searchParams } = new URL(req.url)
    const id = searchParams.get('id')
    const { newPassword, updatedBy } = await req.json()

    if (!id || !newPassword) {
      return NextResponse.json({
        success: false,
        error: 'ç¼ºå°‘å¿…éœ€å‚æ•°',
        message: 'ç”¨æˆ·IDå’Œæ–°å¯†ç æ˜¯å¿…éœ€çš„'
      }, { status: 400 })
    }

    if (newPassword.length < 8) {
      return NextResponse.json({
        success: false,
        error: 'å¯†ç å¼ºåº¦ä¸è¶³',
        message: 'æ–°å¯†ç é•¿åº¦è‡³å°‘ä¸º8ä½'
      }, { status: 400 })
    }

    const supabase = createServiceClient()

    // è·å–ç”¨æˆ·æ•°æ®
    const { data: user, error: fetchError } = await supabase
      .from('admin_users')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !user) {
      return NextResponse.json({
        success: false,
        error: 'ç”¨æˆ·ä¸å­˜åœ¨',
        message: 'æŒ‡å®šçš„ç”¨æˆ·ä¸å­˜åœ¨'
      }, { status: 404 })
    }

    // å¯†ç å“ˆå¸Œå¤„ç†
    const passwordHash = await bcrypt.hash(newPassword, 12)

    // æ›´æ–°å¯†ç 
    const { data: updatedUser, error: updateError } = await supabase
      .from('admin_users')
      .update({
        password_hash: passwordHash,
        updated_at: new Date().toISOString(),
        updated_by: updatedBy || 'system',
        last_login: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single()

    if (updateError) {
      console.error('âŒ é‡ç½®å¯†ç å¤±è´¥:', updateError)
      return NextResponse.json({
        success: false,
        error: 'é‡ç½®å¯†ç å¤±è´¥',
        message: updateError.message
      }, { status: 500 })
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await logAdminAction({
      adminId: updatedBy || 'system',
      action: AdminAction.USER_WRITE,
      resourceType: 'user',
      resourceId: id,
      newValues: {
        password_reset: true,
        last_login: new Date().toISOString()
      },
      ipAddress: req.ip,
      userAgent: req.headers.get('user-agent') || undefined
    })

    console.log(`âœ… ç®¡ç†å‘˜å¯†ç é‡ç½®æˆåŠŸ: ${user.email}`)

    return NextResponse.json({
      success: true,
      message: 'å¯†ç é‡ç½®æˆåŠŸ'
    })

  } catch (error) {
    console.error('âŒ é‡ç½®å¯†ç å¤±è´¥:', error)
    return NextResponse.json({
      success: false,
      error: 'é‡ç½®å¯†ç å¤±è´¥',
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
    }, { status: 500 })
  }
}

// å¯¼å‡ºå¸¦æœ‰ RBAC ä¿æŠ¤çš„å¤„ç†å™¨
export const GET = withRBAC(AdminAction.USER_READ)(handleGET)
export const POST = withRBAC(AdminAction.USER_WRITE)(handlePOST)
export const PUT = withRBAC(AdminAction.USER_WRITE)(handlePUT)
export const PATCH = withRBAC(AdminAction.USER_WRITE)(handlePATCH)
