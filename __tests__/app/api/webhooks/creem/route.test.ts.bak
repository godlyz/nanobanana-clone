/**
 * Creem Webhook æµ‹è¯•å¥—ä»¶
 * è€çŽ‹å¤‡æ³¨: è¿™ä¸ªSBæµ‹è¯•æ–‡ä»¶è¦†ç›– webhook å¤„ç†çš„æ ¸å¿ƒåŠŸèƒ½
 *
 * æµ‹è¯•èŒƒå›´:
 * 1. Webhook ç­¾åéªŒè¯
 * 2. checkout.completed äº‹ä»¶å¤„ç†ï¼ˆç§¯åˆ†åŒ… + è®¢é˜…ï¼‰
 * 3. subscription.* äº‹ä»¶å¤„ç†
 * 4. payment.* äº‹ä»¶å¤„ç†
 * 5. æœªçŸ¥äº‹ä»¶ç±»åž‹å¤„ç†
 * 6. é”™è¯¯å¤„ç†å’Œå¼‚å¸¸æƒ…å†µ
 * 7. ç­¾åéªŒè¯å¤±è´¥åœºæ™¯
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { POST } from '@/app/api/webhooks/creem/route'
import { NextRequest } from 'next/server'
import crypto from 'crypto'
import { createCreditService } from '@/lib/credit-service'
import { createClient } from '@/lib/supabase/server'
import {
  handleUpgradeDowngradePrepare,
  handleCreditFreeze,
} from '@/lib/subscription/upgrade-downgrade'

// ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šä½¿ç”¨ vi.spyOn åœ¨è¿è¡Œæ—¶ spy crypto.createHmac
// è¿™æ ·å¯ä»¥é¿å… vi.mock çš„ TDZ é—®é¢˜

// ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šç¡®ä¿åŠ¨æ€importä¹Ÿèƒ½ä½¿ç”¨mock
// ä½¿ç”¨è‡ªåŠ¨æå‡(hoisted)çš„mockï¼Œæ”¯æŒé™æ€å’ŒåŠ¨æ€import
vi.mock('@/lib/credit-service', async (importOriginal) => {
  // ðŸ”¥ åˆ›å»ºä¸€ä¸ªmockç±»ï¼Œå®žä¾‹åŒ–æ—¶è¿”å›žåŒ…å«addCreditsæ–¹æ³•çš„å¯¹è±¡
  class MockCreditService {
    addCredits = vi.fn().mockResolvedValue(undefined)
    deductCredits = vi.fn().mockResolvedValue(undefined)
    getUserAvailableCredits = vi.fn().mockResolvedValue(1000)
    checkCreditsSufficient = vi.fn().mockResolvedValue(true)

    constructor(_supabase: any) {
      // Mock constructorï¼Œå¿½ç•¥supabaseå‚æ•°
    }
  }

  return {
    createCreditService: vi.fn(),
    CreditService: MockCreditService, // âœ… ä½¿ç”¨çœŸæ­£çš„ç±»ï¼Œè€Œä¸æ˜¯å‡½æ•°
  }
})

vi.mock('@/lib/supabase/server', () => ({
  createClient: vi.fn(),
}))

vi.mock('@/lib/credit-types', () => ({
  SUBSCRIPTION_MONTHLY_CREDITS: {
    basic: 100,
    pro: 500,
    max: 999999,
  },
  SUBSCRIPTION_YEARLY_ACTUAL_CREDITS: {
    basic: 1440, // 100 * 12 * 1.2
    pro: 7200, // 500 * 12 * 1.2
    max: 14399880, // 999999 * 12 * 1.2
  },
}))

// ðŸ”¥ è€çŽ‹é‡æž„ï¼šMock upgrade/downgradeæ¨¡å—ï¼ˆè§£å†³vi.doMocké™åˆ¶ï¼‰
vi.mock('@/lib/subscription/upgrade-downgrade', () => ({
  handleUpgradeDowngradePrepare: vi.fn(),
  handleCreditFreeze: vi.fn(),
}))

describe('POST /api/webhooks/creem', () => {
  let mockCreditService: any
  let mockSupabase: any
  let originalEnv: NodeJS.ProcessEnv
  let mockDigest: ReturnType<typeof vi.fn> // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šæå‡åˆ°describeçº§åˆ«

  // ðŸ”¥ è€çŽ‹åˆ é™¤ï¼šgenerateSignature å‡½æ•°å·²è¢«å›ºå®šç­¾åå€¼æ›¿ä»£ï¼Œä¸å†éœ€è¦

  // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»º webhook è¯·æ±‚
  // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„ Creem Webhook æ ¼å¼ï¼ˆeventType + objectï¼‰
  function createWebhookRequest(eventType: string, data: any, signature?: string) {
    const payload = JSON.stringify({
      id: `evt_${Date.now()}`,
      eventType,  // ðŸ”¥ å­—æ®µåæ˜¯ eventTypeï¼Œä¸æ˜¯ type
      created_at: Date.now(),
      object: data,  // ðŸ”¥ å­—æ®µåæ˜¯ objectï¼Œä¸æ˜¯ data
    })

    const headers = new Headers()
    headers.set('content-type', 'application/json')
    if (signature) {
      headers.set('creem-signature', signature)
    }

    return new NextRequest('http://localhost:3000/api/webhooks/creem', {
      method: 'POST',
      headers,
      body: payload,
    })
  }

  beforeEach(() => {
    // ä¿å­˜åŽŸå§‹çŽ¯å¢ƒå˜é‡
    originalEnv = { ...process.env }

    // è®¾ç½®æµ‹è¯•çŽ¯å¢ƒå˜é‡
    process.env.CREEM_WEBHOOK_SECRET = 'test_webhook_secret_123'

    // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šä½¿ç”¨ vi.spyOn spy crypto.createHmac
    // è®©å®ƒè¿”å›žä¸€ä¸ªmockå¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„ update().digest() è¿”å›žå›ºå®šç­¾å
    mockDigest = vi.fn(() => 'valid-signature') // èµ‹å€¼ç»™describeçº§åˆ«çš„å˜é‡
    const mockUpdate = vi.fn(() => ({ digest: mockDigest }))
    vi.spyOn(crypto, 'createHmac').mockReturnValue({ update: mockUpdate } as any)

    // Mock CreditService
    mockCreditService = {
      createSubscription: vi.fn().mockResolvedValue('sub-123'),
      refillSubscriptionCredits: vi.fn().mockResolvedValue(undefined),
      creditPackagePurchase: vi.fn().mockResolvedValue(undefined),
      addCredits: vi.fn().mockResolvedValue(undefined), // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šç›´æŽ¥åœ¨è¿™é‡Œæ·»åŠ  addCredits
    }

    vi.mocked(createCreditService).mockResolvedValue(mockCreditService)

    // ðŸ”¥ è€çŽ‹é‡å¤§ä¿®å¤ï¼šMock Supabase æ ¹æ®è¡¨åè¿”å›žä¸åŒçš„æ•°æ®
    mockSupabase = {
      from: vi.fn((tableName: string) => {
        // ðŸ”¥ æ ¹æ®è¡¨åè¿”å›žä¸åŒçš„ mock æ•°æ®
        if (tableName === 'credit_packages') {
          // ç§¯åˆ†åŒ…è¡¨çš„ mock æ•°æ®
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: {
                    package_code: 'CREDIT_100',
                    price_usd: 9.99,
                    credits: 100,
                    name_zh: '100 ç§¯åˆ†åŒ…',
                  },
                  error: null,
                })),
              })),
            })),
            insert: vi.fn(() => Promise.resolve({ error: null })),
            upsert: vi.fn(() => Promise.resolve({ error: null })),
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        } else if (tableName === 'user_subscriptions') {
          // ðŸ”¥ è®¢é˜…è¡¨çš„ mock æ•°æ®ï¼ˆåŒ…å«æ­£ç¡®çš„å­—æ®µï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: {
                    subscription_id: 'sub_old_123',
                    user_id: 'user_old_456',
                    product_id: 'prod_basic_monthly', // âœ… æ­£ç¡®çš„å­—æ®µå
                    billing_cycle: 'monthly',         // âœ… æ­£ç¡®çš„å­—æ®µå
                    status: 'active',
                    current_period_start: new Date().toISOString(),
                    current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                  },
                  error: null,
                })),
              })),
            })),
            insert: vi.fn(() => Promise.resolve({ error: null })),
            upsert: vi.fn(() => Promise.resolve({ error: null })),
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        } else {
          // é»˜è®¤ mockï¼ˆé€šç”¨è¡¨ï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({ data: {}, error: null })),
              })),
            })),
            insert: vi.fn(() => Promise.resolve({ error: null })),
            upsert: vi.fn(() => Promise.resolve({ error: null })),
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        }
      }),
    }

    vi.mocked(createClient).mockResolvedValue(mockSupabase)

    vi.clearAllMocks()
  })

  afterEach(() => {
    // æ¢å¤åŽŸå§‹çŽ¯å¢ƒå˜é‡
    process.env = originalEnv
    vi.resetAllMocks()
  })

  describe('é…ç½®éªŒè¯', () => {
    it('åº”è¯¥æ‹’ç»æœªé…ç½® CREEM_WEBHOOK_SECRET çš„è¯·æ±‚', async () => {
      delete process.env.CREEM_WEBHOOK_SECRET

      const request = createWebhookRequest('test.event', {}, 'fake-signature')
      const response = await POST(request)
      const data = await response.json()

      // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼ˆ2025-11-08ï¼‰ï¼šç”±äºŽçŽ¯å¢ƒå˜é‡å·²ç§»åˆ°å‡½æ•°å†…éƒ¨è¯»å–
      // delete åŽä¼šè¯»å–åˆ° undefinedï¼Œç›´æŽ¥è¿”å›ž 500 "Webhook not configured"
      // ä¸å†æ˜¯ä¹‹å‰çš„æ¨¡å—ç¼“å­˜è¡Œä¸ºï¼ˆå¸¸é‡ä¿ç•™å€¼ï¼Œè¿›å…¥ç­¾åéªŒè¯è¿”å›ž401ï¼‰
      expect(response.status).toBe(500)
      expect(data.error).toBe('Webhook not configured')
    })
  })

  describe('ç­¾åéªŒè¯', () => {
    it('åº”è¯¥æ‹’ç»ç¼ºå°‘ç­¾åçš„è¯·æ±‚', async () => {
      const request = createWebhookRequest('test.event', {}) // ä¸ä¼  signature
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(400)
      expect(data.error).toBe('Missing signature')
    })

    it('åº”è¯¥æ‹’ç»ç­¾åæ— æ•ˆçš„è¯·æ±‚', async () => {
      // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šé…ç½® mock è¿”å›žä¸åŒçš„ç­¾å
      mockDigest.mockReturnValueOnce('different-signature')

      const request = createWebhookRequest('test.event', {}, 'invalid-signature')
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Invalid signature')
    })

    it('åº”è¯¥æŽ¥å—ç­¾åæœ‰æ•ˆçš„è¯·æ±‚', async () => {
      const eventData = { id: 'evt_123', object: 'event', created_at: new Date().toISOString() }

      // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šä½¿ç”¨å›ºå®šç­¾åå€¼ï¼Œå’Œ mock è¿”å›žçš„ä¸€è‡´
      const request = createWebhookRequest('unknown.event', eventData, 'valid-signature')
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.received).toBe(true)
    })

    it('åº”è¯¥å¤„ç†ç­¾åéªŒè¯è¿‡ç¨‹ä¸­çš„å¼‚å¸¸', async () => {
      // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šæµ‹è¯•ç­¾åéªŒè¯æŠ›å‡ºå¼‚å¸¸çš„æƒ…å†µï¼ˆè¦†ç›– lines 118-119ï¼‰
      vi.spyOn(crypto, 'createHmac').mockImplementationOnce(() => {
        throw new Error('Crypto error')
      })

      const request = createWebhookRequest('test.event', {}, 'some-signature')
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(401)
      expect(data.error).toBe('Invalid signature')
    })
  })

  describe('checkout.completed - ç§¯åˆ†åŒ…è´­ä¹°', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†ç§¯åˆ†åŒ…è´­ä¹°å®Œæˆäº‹ä»¶', async () => {
      const eventData = {
        id: 'checkout_123',
        checkout_id: 'checkout_123',
        order_id: 'order_456',
        product_id: 'prod_credit_100',
        amount: 9.99,
        currency: 'USD',
        metadata: {
          type: 'credit_package',
          user_id: 'user-789',
          package_code: 'CREDIT_100',
          credits: 100,
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(200)
      expect(data.received).toBe(true)

      // éªŒè¯ç§¯åˆ†å……å€¼è°ƒç”¨
      expect(mockCreditService.creditPackagePurchase).toHaveBeenCalledWith(
        'user-789',
        'order_456',
        100,
        '100 ç§¯åˆ†åŒ…'
      )

      // éªŒè¯è®¢å•è®°å½•
      expect(mockSupabase.from).toHaveBeenCalledWith('subscription_orders')
    })

    it('åº”è¯¥å¤„ç†ç§¯åˆ†åŒ…è´­ä¹°ç¼ºå°‘å‚æ•°çš„æƒ…å†µ', async () => {
      const eventData = {
        id: 'checkout_invalid',
        metadata: {
          type: 'credit_package',
          // ç¼ºå°‘ user_id, package_code, credits
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)
      const data = await response.json()

      // åº”è¯¥è¿”å›žæˆåŠŸä½†ä¸è°ƒç”¨ç§¯åˆ†å……å€¼
      expect(response.status).toBe(200)
      expect(mockCreditService.creditPackagePurchase).not.toHaveBeenCalled()
    })

    it('åº”è¯¥å¤„ç†ç§¯åˆ†åŒ…æŸ¥è¯¢å¤±è´¥çš„æƒ…å†µ', async () => {
      // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šæµ‹è¯•ç§¯åˆ†åŒ…æŸ¥è¯¢å¤±è´¥ï¼ˆè¦†ç›– lines 172-173ï¼‰
      // ä¸´æ—¶ä¿®æ”¹ mockSupabase.from å¯¹ credit_packages è¡¨çš„ mock è¿”å›žé”™è¯¯
      const originalFrom = mockSupabase.from
      mockSupabase.from = vi.fn((tableName: string) => {
        if (tableName === 'credit_packages') {
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: null,
                  error: { message: 'Database error' }
                }))
              }))
            }))
          }
        }
        return originalFrom(tableName)
      })

      const eventData = {
        id: 'checkout_db_error',
        checkout_id: 'checkout_db_error',
        order_id: 'order_db_error',
        product_id: 'prod_credit_100',
        metadata: {
          type: 'credit_package',
          user_id: 'user-error',
          package_code: 'CREDIT_100',
          credits: 100,
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)
      const data = await response.json()

      // åº”è¯¥è¿”å›žæˆåŠŸï¼ˆæ—©æœŸreturnï¼Œä¸æŠ›å‡ºå¼‚å¸¸ï¼‰
      expect(response.status).toBe(200)
      expect(mockCreditService.creditPackagePurchase).not.toHaveBeenCalled()

      // æ¢å¤åŽŸå§‹ mock
      mockSupabase.from = originalFrom
    })
  })

  describe('checkout.completed - è®¢é˜…è´­ä¹°', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†æœˆä»˜è®¢é˜…è´­ä¹°å®Œæˆäº‹ä»¶', async () => {
      const eventData = {
        id: 'checkout_sub_123',
        checkout_id: 'checkout_sub_123',
        order_id: 'order_sub_456',
        product_id: 'prod_pro_monthly',
        subscription_id: 'sub_789',
        amount: 19.99,
        currency: 'USD',
        metadata: {
          type: 'subscription',
          user_id: 'user-abc',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)
      const data = await response.json()

      expect(response.status).toBe(200)

      // éªŒè¯è®¢é˜…åˆ›å»º
      expect(mockCreditService.createSubscription).toHaveBeenCalledWith({
        user_id: 'user-abc',
        plan_tier: 'pro',
        billing_cycle: 'monthly',
        monthly_credits: 500,
        creem_subscription_id: 'sub_789',
      })

      // éªŒè¯ç§¯åˆ†å……å€¼ï¼ˆæœˆä»˜ï¼‰
      // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šrefillSubscriptionCredits æœ‰ 6 ä¸ªå‚æ•°ï¼Œæœ€åŽä¸€ä¸ªæ˜¯ isRenewal
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalledWith(
        'user-abc',
        'sub-123',
        500, // æœˆä»˜å°±æ˜¯ monthly_credits
        'pro',
        'monthly',
        true  // ðŸ”¥ isRenewal: é¦–æ¬¡è´­ä¹°ä¹Ÿè§†ä¸ºç»­è´¹ï¼ˆaction !== 'upgrade' && action !== 'downgrade'ï¼‰
      )
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†å¹´ä»˜è®¢é˜…è´­ä¹°å®Œæˆäº‹ä»¶', async () => {
      const eventData = {
        id: 'checkout_yearly',
        checkout_id: 'checkout_yearly',
        order_id: 'order_yearly',
        product_id: 'prod_basic_yearly',
        subscription_id: 'sub_yearly',
        amount: 99.99,
        currency: 'USD',
        metadata: {
          type: 'subscription',
          user_id: 'user-yearly',
          plan_tier: 'basic',
          billing_cycle: 'yearly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)

      expect(response.status).toBe(200)

      // éªŒè¯å¹´ä»˜ç§¯åˆ†å……å€¼ï¼ˆ12ä¸ªæœˆ + 20%èµ é€ï¼‰
      // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šrefillSubscriptionCredits æœ‰ 6 ä¸ªå‚æ•°ï¼Œæœ€åŽä¸€ä¸ªæ˜¯ isRenewal
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalledWith(
        'user-yearly',
        'sub-123',
        1440, // 100 * 12 * 1.2
        'basic',
        'yearly',
        true  // ðŸ”¥ isRenewal: é¦–æ¬¡è´­ä¹°ä¹Ÿè§†ä¸ºç»­è´¹
      )
    })

    it('åº”è¯¥å¤„ç†è®¢é˜…è´­ä¹°ç¼ºå°‘å‚æ•°çš„æƒ…å†µ', async () => {
      const eventData = {
        id: 'checkout_invalid_sub',
        metadata: {
          type: 'subscription',
          // ç¼ºå°‘ user_id, plan_tier, billing_cycle
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)

      // åº”è¯¥è¿”å›žæˆåŠŸä½†ä¸åˆ›å»ºè®¢é˜…
      expect(response.status).toBe(200)
      expect(mockCreditService.createSubscription).not.toHaveBeenCalled()
    })
  })

  // ðŸ”¥ è€çŽ‹é‡æž„ï¼šè¯¦ç»†æµ‹è¯•å„ä¸ªevent handlerçš„å†…éƒ¨é€»è¾‘
  describe('subscription.created äº‹ä»¶è¯¦ç»†æµ‹è¯•', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…åˆ›å»ºå¹¶æ·»åŠ ç§¯åˆ†ï¼ˆBasicæœˆä»˜ï¼‰', async () => {
      const eventData = {
        subscription_id: 'sub_created_basic',
        customer_id: 'cust_basic_123',
        product_id: 'prod_basic_monthly',
        status: 'active',
        created_at: new Date().toISOString(),
        billing_cycle: 'monthly',
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.created', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥è°ƒç”¨upsertåˆ›å»ºè®¢é˜…è®°å½•
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…åˆ›å»ºå¹¶æ·»åŠ ç§¯åˆ†ï¼ˆProå¹´ä»˜ï¼‰', async () => {
      vi.clearAllMocks()

      const eventData = {
        subscription_id: 'sub_created_pro',
        customer_id: 'cust_pro_456',
        product_id: 'prod_pro_yearly',
        status: 'active',
        created_at: new Date().toISOString(),
        billing_cycle: 'yearly',
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.created', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…åˆ›å»ºå¹¶æ·»åŠ ç§¯åˆ†ï¼ˆMaxå¥—é¤ï¼‰', async () => {
      vi.clearAllMocks()

      const eventData = {
        subscription_id: 'sub_created_max',
        customer_id: 'cust_max_789',
        product_id: 'prod_max_monthly',
        status: 'active',
        created_at: new Date().toISOString(),
        billing_cycle: 'monthly',
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.created', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })

    it('åº”è¯¥å¤„ç†è®¢é˜…åˆ›å»ºæ—¶æ•°æ®åº“é”™è¯¯', async () => {
      // Mock upsertå¤±è´¥
      mockSupabase.from.mockReturnValueOnce({
        upsert: vi.fn(() => Promise.resolve({
          error: { message: 'Database error' },
        })),
      })

      const eventData = {
        subscription_id: 'sub_created_error',
        customer_id: 'cust_error',
        product_id: 'prod_basic_monthly',
        status: 'active',
        created_at: new Date().toISOString(),
        billing_cycle: 'monthly',
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.created', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
    })
  })

  describe('subscription.updated äº‹ä»¶è¯¦ç»†æµ‹è¯•', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…æ›´æ–°ï¼ˆæ— å‡çº§é™çº§ï¼‰', async () => {
      vi.clearAllMocks()

      const eventData = {
        subscription_id: 'sub_updated_123',
        customer_id: 'cust_updated_456',
        product_id: 'prod_basic_monthly',
        status: 'active',
        billing_cycle: 'monthly',
        current_period_start: new Date().toISOString(),
        current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.updated', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥æŸ¥è¯¢æ—§è®¢é˜…å¹¶æ›´æ–°
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…å‡çº§ï¼ˆBasic -> Proï¼‰', async () => {
      vi.clearAllMocks()

      // MockæŸ¥è¯¢æ—§è®¢é˜…è¿”å›žBasicå¥—é¤
      let fromCallCount = 0
      mockSupabase.from = vi.fn((tableName: string) => {
        if (tableName === 'user_subscriptions') {
          fromCallCount++
          if (fromCallCount === 1) {
            // ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼šæŸ¥è¯¢æ—§è®¢é˜…ï¼Œè¿”å›žBasicå¥—é¤
            return {
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  single: vi.fn(() => Promise.resolve({
                    data: {
                      subscription_id: 'sub_upgrade_123',
                      user_id: 'cust_upgrade_456',
                      product_id: 'prod_basic_monthly', // æ—§å¥—é¤ï¼šBasic
                      billing_cycle: 'monthly',
                      status: 'active',
                    },
                    error: null,
                  })),
                })),
              })),
            }
          } else {
            // ç¬¬äºŒæ¬¡è°ƒç”¨ï¼šæ›´æ–°è®¢é˜…
            return {
              upsert: vi.fn(() => Promise.resolve({ error: null })),
            }
          }
        }
        // å…¶ä»–è¡¨çš„é»˜è®¤mock
        return {
          insert: vi.fn(() => Promise.resolve({ error: null })),
          update: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ error: null })),
          })),
        }
      })

      const eventData = {
        subscription_id: 'sub_upgrade_123',
        customer_id: 'cust_upgrade_456',
        product_id: 'prod_pro_monthly', // æ–°å¥—é¤ï¼šProï¼ˆç§¯åˆ†æ›´å¤šï¼‰
        status: 'active',
        billing_cycle: 'monthly',
        current_period_start: new Date().toISOString(),
        current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.updated', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥è°ƒç”¨addCreditså¢žåŠ ç§¯åˆ†å·®é¢
      // éªŒè¯æ˜¯å¦è°ƒç”¨äº†addCreditsï¼ˆå‡çº§åœºæ™¯ï¼‰
      const addCreditsCalls = mockCreditService.addCredits.mock.calls
      if (addCreditsCalls.length > 0) {
        const callArgs = addCreditsCalls[0][0]
        expect(callArgs.transaction_type).toBe('subscription_upgrade')
        expect(callArgs.amount).toBeGreaterThan(0)
      }
    })
  })

  describe('subscription.cancelled äº‹ä»¶è¯¦ç»†æµ‹è¯•', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…å–æ¶ˆ', async () => {
      vi.clearAllMocks()

      const eventData = {
        subscription_id: 'sub_cancelled_123',
        customer_id: 'cust_cancelled_456',
        cancelled_at: new Date().toISOString(),
        current_period_end: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.cancelled', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥æ›´æ–°è®¢é˜…çŠ¶æ€ä¸ºcancelled
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })
  })

  describe('payment.succeeded äº‹ä»¶è¯¦ç»†æµ‹è¯•', () => {
    it('åº”è¯¥æˆåŠŸè®°å½•æ”¯ä»˜æˆåŠŸ', async () => {
      vi.clearAllMocks()

      const eventData = {
        order_id: 'order_success_123',
        customer_id: 'cust_success_456',
        product_id: 'prod_basic_monthly',
        amount: 9.99,
        currency: 'USD',
        paid_at: new Date().toISOString(),
        object: 'payment',
      }

      const request = createWebhookRequest('payment.succeeded', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥æ›´æ–°è®¢å•çŠ¶æ€å’Œè®°å½•æ”¯ä»˜åŽ†å²
      expect(mockSupabase.from).toHaveBeenCalledWith('payment_orders')
    })

    it('åº”è¯¥å¤„ç†æ›´æ–°è®¢å•çŠ¶æ€å¤±è´¥çš„æƒ…å†µ', async () => {
      vi.clearAllMocks()

      // Mockæ›´æ–°è®¢å•å¤±è´¥
      const mockError = { message: 'Update order failed' }
      mockSupabase.from = vi.fn((tableName: string) => {
        if (tableName === 'payment_orders') {
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: mockError }))
            }))
          }
        }
        return {
          insert: vi.fn(() => Promise.resolve({ error: null })),
        }
      })

      const eventData = {
        order_id: 'order_err',
        customer_id: 'cust_err',
        amount: 9.99,
        paid_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('payment.succeeded', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('Webhook processing failed')
    })

    it('åº”è¯¥å¤„ç†è®°å½•æ”¯ä»˜åŽ†å²å¤±è´¥ä½†ç»§ç»­å¤„ç†', async () => {
      vi.clearAllMocks()

      // Mockæ”¯ä»˜åŽ†å²æ’å…¥å¤±è´¥ï¼ˆéžè‡´å‘½é”™è¯¯ï¼‰
      let callCount = 0
      mockSupabase.from = vi.fn((tableName: string) => {
        if (tableName === 'payment_orders') {
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null }))
            }))
          }
        }
        if (tableName === 'payment_history') {
          return {
            insert: vi.fn(() => Promise.resolve({
              error: { message: 'Insert history failed' }
            }))
          }
        }
        return {
          insert: vi.fn(() => Promise.resolve({ error: null })),
        }
      })

      const eventData = {
        order_id: 'order_history_err',
        customer_id: 'cust_history_err',
        amount: 9.99,
        paid_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('payment.succeeded', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥ä»ç„¶è¿”å›ž200ï¼ˆéžè‡´å‘½é”™è¯¯ï¼‰
      expect(response.status).toBe(200)
    })
  })

  describe('payment.failed äº‹ä»¶è¯¦ç»†æµ‹è¯•', () => {
    it('åº”è¯¥æˆåŠŸè®°å½•æ”¯ä»˜å¤±è´¥', async () => {
      vi.clearAllMocks()

      const eventData = {
        order_id: 'order_failed_123',
        customer_id: 'cust_failed_456',
        product_id: 'prod_basic_monthly',
        amount: 9.99,
        error_message: 'Card declined',
        failed_at: new Date().toISOString(),
        object: 'payment',
      }

      const request = createWebhookRequest('payment.failed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥æ›´æ–°è®¢å•å¤±è´¥çŠ¶æ€
      expect(mockSupabase.from).toHaveBeenCalledWith('payment_orders')
    })

    it('åº”è¯¥å¤„ç†payment.failedäº‹ä»¶ä¸­çš„æ•°æ®åº“é”™è¯¯', async () => {
      vi.clearAllMocks()

      // Mockæ•°æ®åº“æ›´æ–°å¤±è´¥
      const mockError = { message: 'Database update failed' }
      mockSupabase.from = vi.fn(() => ({
        update: vi.fn(() => ({
          eq: vi.fn(() => Promise.resolve({ error: mockError }))
        })),
        insert: vi.fn(() => Promise.resolve({ error: null })),
      }))

      const eventData = {
        order_id: 'order_failed_err',
        customer_id: 'cust_failed_err',
        error_message: 'Test error',
        failed_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('payment.failed', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('Webhook processing failed')
    })

    it('åº”è¯¥å¤„ç†è®°å½•æ”¯ä»˜åŽ†å²å¤±è´¥çš„æƒ…å†µï¼ˆLine 840ï¼‰', async () => {
      vi.clearAllMocks()

      // ðŸ”¥ Mockç­–ç•¥ï¼šæ›´æ–°è®¢å•çŠ¶æ€æˆåŠŸï¼Œä½†æ’å…¥æ”¯ä»˜åŽ†å²å¤±è´¥
      mockSupabase.from = vi.fn((tableName: string) => {
        if (tableName === 'payment_orders') {
          // æ›´æ–°è®¢å•çŠ¶æ€ - æˆåŠŸ
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        } else if (tableName === 'payment_history') {
          // æ’å…¥æ”¯ä»˜åŽ†å² - ðŸ”¥ å¤±è´¥ï¼ˆè§¦å‘Line 840ï¼‰
          return {
            insert: vi.fn(() => Promise.resolve({
              error: { message: 'Insert payment history failed' },
            })),
          }
        }
        return {
          update: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ error: null })),
          })),
          insert: vi.fn(() => Promise.resolve({ error: null })),
        }
      })

      const eventData = {
        order_id: 'order_history_fail',
        customer_id: 'cust_history_fail',
        product_id: 'prod_basic_monthly',
        amount: 9.99,
        error_message: 'Test failure',
        failed_at: new Date().toISOString(),
        object: 'payment',
      }

      const request = createWebhookRequest('payment.failed', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž200ï¼ˆè®°å½•åŽ†å²å¤±è´¥æ˜¯éžè‡´å‘½é”™è¯¯ï¼Œä¼šconsole.errorä½†ä¸æŠ›å‡ºå¼‚å¸¸ï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })
  })

  describe('æœªçŸ¥äº‹ä»¶ç±»åž‹', () => {
    it('åº”è¯¥æŽ¥å—æœªçŸ¥äº‹ä»¶ç±»åž‹å¹¶è¿”å›žæˆåŠŸ', async () => {
      const eventData = {
        id: 'evt_unknown',
        object: 'event',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('unknown.event.type', eventData, 'valid-signature')
      const response = await POST(request)
      const data = await response.json()

      // æœªçŸ¥äº‹ä»¶ä¹Ÿåº”è¯¥è¿”å›žæˆåŠŸ
      expect(response.status).toBe(200)
      expect(data.received).toBe(true)
    })
  })

  describe('é”™è¯¯å¤„ç†', () => {
    it('åº”è¯¥å¤„ç† checkout.completed äº‹ä»¶å¤„ç†ä¸­çš„å¼‚å¸¸', async () => {
      // Mock CreditService æŠ›å‡ºå¼‚å¸¸
      mockCreditService.creditPackagePurchase.mockRejectedValue(
        new Error('Database error')
      )

      const eventData = {
        id: 'checkout_error',
        order_id: 'order_error',
        product_id: 'prod_error',
        metadata: {
          type: 'credit_package',
          user_id: 'user-error',
          package_code: 'CREDIT_100',
          credits: 100,
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)
      const data = await response.json()

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      expect(data.error).toBe('Webhook processing failed')
    })

    it('åº”è¯¥å¤„ç†æ— æ•ˆçš„ JSON æ ¼å¼', async () => {
      const headers = new Headers()
      headers.set('content-type', 'application/json')
      headers.set('creem-signature', 'invalid')

      const request = new NextRequest('http://localhost:3000/api/webhooks/creem', {
        method: 'POST',
        headers,
        body: 'invalid json{',
      })

      const response = await POST(request)
      const data = await response.json()

      // ç­¾åéªŒè¯å¤±è´¥æˆ–JSONè§£æžå¤±è´¥éƒ½ä¼šè¿”å›žé”™è¯¯
      expect(response.status).toBeGreaterThanOrEqual(400)
    })

    it('åº”è¯¥å¤„ç†è®¢é˜…åˆ›å»ºå¤±è´¥çš„æƒ…å†µ', async () => {
      mockCreditService.createSubscription.mockRejectedValue(
        new Error('Failed to create subscription')
      )

      const eventData = {
        id: 'checkout_sub_fail',
        metadata: {
          type: 'subscription',
          user_id: 'user-fail',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)

      expect(response.status).toBe(500)
    })
  })

  describe('æ•°æ®åº“æ“ä½œ', () => {
    it('åº”è¯¥è®°å½•ç§¯åˆ†åŒ…è´­ä¹°è®¢å•', async () => {
      const eventData = {
        id: 'checkout_db',
        checkout_id: 'checkout_db',
        order_id: 'order_db',
        product_id: 'prod_db',
        metadata: {
          type: 'credit_package',
          user_id: 'user-db',
          package_code: 'CREDIT_100',
          credits: 100,
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      await POST(request)

      // éªŒè¯æ•°æ®åº“æ’å…¥è°ƒç”¨
      const fromCall = mockSupabase.from.mock.calls.find(
        (call: any) => call[0] === 'subscription_orders'
      )
      expect(fromCall).toBeDefined()
    })

    it('åº”è¯¥å¤„ç†æ•°æ®åº“æ’å…¥å¤±è´¥ä½†ç»§ç»­å……å€¼ç§¯åˆ†', async () => {
      // Mock æ•°æ®åº“æ’å…¥å¤±è´¥
      mockSupabase.from.mockReturnValue({
        select: vi.fn(() => ({
          eq: vi.fn(() => ({
            single: vi.fn(() => Promise.resolve({
              data: {
                package_code: 'CREDIT_100',
                price_usd: 9.99,
                credits: 100,
                name_zh: '100 ç§¯åˆ†åŒ…',
              },
              error: null,
            })),
          })),
        })),
        insert: vi.fn(() => Promise.resolve({
          error: { message: 'Insert failed' },
        })),
      })

      const eventData = {
        id: 'checkout_db_fail',
        order_id: 'order_db_fail',
        product_id: 'prod_db_fail',
        metadata: {
          type: 'credit_package',
          user_id: 'user-db-fail',
          package_code: 'CREDIT_100',
          credits: 100,
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)

      // å³ä½¿æ•°æ®åº“æ’å…¥å¤±è´¥ï¼Œä¹Ÿåº”è¯¥æˆåŠŸå……å€¼ç§¯åˆ†
      expect(response.status).toBe(200)
      expect(mockCreditService.creditPackagePurchase).toHaveBeenCalled()
    })
  })

  describe('è¾¹ç•Œæƒ…å†µ', () => {
    it('åº”è¯¥å¤„ç† metadata ä¸ºç©ºçš„æƒ…å†µ', async () => {
      const eventData = {
        id: 'checkout_no_metadata',
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const payload = JSON.stringify({
        type: 'checkout.completed',
        data: eventData,
      })
      const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

      const request = createWebhookRequest('checkout.completed', eventData, signature)
      const response = await POST(request)

      // åº”è¯¥è¿”å›žæˆåŠŸä½†ä¸æ‰§è¡Œä»»ä½•ä¸šåŠ¡é€»è¾‘
      expect(response.status).toBe(200)
    })

    it('åº”è¯¥å¤„ç†æ‰€æœ‰æ”¯æŒçš„è®¢é˜…å¥—é¤', async () => {
      const plans = ['basic', 'pro', 'max']
      const cycles = ['monthly', 'yearly']

      for (const plan of plans) {
        for (const cycle of cycles) {
          vi.clearAllMocks()

          const eventData = {
            id: `checkout_${plan}_${cycle}`,
            metadata: {
              type: 'subscription',
              user_id: `user-${plan}-${cycle}`,
              plan_tier: plan,
              billing_cycle: cycle,
            },
            object: 'checkout',
            created_at: new Date().toISOString(),
          }

          const payload = JSON.stringify({
            type: 'checkout.completed',
            data: eventData,
          })
          const signature = 'valid-signature' // ðŸ”¥ è€çŽ‹ä¿®å¤: ä½¿ç”¨å›ºå®šç­¾å

          const request = createWebhookRequest('checkout.completed', eventData, signature)
          const response = await POST(request)

          expect(response.status).toBe(200)
          expect(mockCreditService.createSubscription).toHaveBeenCalledWith(
            expect.objectContaining({
              plan_tier: plan,
              billing_cycle: cycle,
            })
          )
        }
      }
    })
  })

  // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šsubscription.active äº‹ä»¶æµ‹è¯•
  describe('subscription.active äº‹ä»¶', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…æ¿€æ´»äº‹ä»¶ï¼ˆè®¢é˜…ç±»åž‹ï¼‰', async () => {
      const eventData = {
        id: 'sub_active_123',
        subscription_id: 'sub_active_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-active',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.active', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥è°ƒç”¨ handleSubscriptionPurchase
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†å¹´ä»˜è®¢é˜…æ¿€æ´»äº‹ä»¶', async () => {
      vi.clearAllMocks()

      const eventData = {
        id: 'sub_active_yearly_123',
        subscription_id: 'sub_active_yearly_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-active-yearly',
          plan_tier: 'basic',
          billing_cycle: 'yearly', // å¹´ä»˜è®¢é˜…
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.active', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥è°ƒç”¨ handleSubscriptionPurchase
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
      // éªŒè¯è°ƒç”¨å‚æ•°åŒ…å«yearlyå‘¨æœŸ
      const call = mockCreditService.createSubscription.mock.calls[0][0]
      expect(call.billing_cycle).toBe('yearly')
    })

    it('åº”è¯¥è·³è¿‡éžè®¢é˜…ç±»åž‹çš„æ¿€æ´»äº‹ä»¶', async () => {
      const eventData = {
        id: 'sub_active_credit',
        metadata: {
          type: 'credit_package',  // ä¸æ˜¯è®¢é˜…
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.active', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // ä¸åº”è¯¥åˆ›å»ºè®¢é˜…
      expect(mockCreditService.createSubscription).not.toHaveBeenCalled()
    })

    it('åº”è¯¥å¤„ç†subscription.activeäº‹ä»¶ä¸­çš„å¼‚å¸¸', async () => {
      vi.clearAllMocks()

      // Mock createSubscriptionæŠ›å‡ºå¼‚å¸¸
      mockCreditService.createSubscription = vi.fn(() => {
        throw new Error('Subscription creation failed')
      })

      const eventData = {
        id: 'sub_active_err',
        subscription_id: 'sub_active_err_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-active-err',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.active', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('Webhook processing failed')
    })
  })

  // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šsubscription.paid äº‹ä»¶æµ‹è¯•
  describe('subscription.paid äº‹ä»¶', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…ä»˜æ¬¾äº‹ä»¶ï¼ˆè®¢é˜…ç±»åž‹ï¼‰', async () => {
      const eventData = {
        id: 'sub_paid_123',
        subscription_id: 'sub_paid_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-paid',
          plan_tier: 'basic',
          billing_cycle: 'yearly',
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.paid', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥è°ƒç”¨ handleSubscriptionPurchase
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
    })

    it('åº”è¯¥è·³è¿‡éžè®¢é˜…ç±»åž‹çš„ä»˜æ¬¾äº‹ä»¶', async () => {
      const eventData = {
        id: 'sub_paid_credit',
        metadata: {
          type: 'credit_package',  // ä¸æ˜¯è®¢é˜…
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.paid', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // ä¸åº”è¯¥åˆ›å»ºè®¢é˜…
      expect(mockCreditService.createSubscription).not.toHaveBeenCalled()
    })

    it('åº”è¯¥å¤„ç†subscription.paidäº‹ä»¶ä¸­çš„å¼‚å¸¸', async () => {
      vi.clearAllMocks()

      // Mock createSubscriptionæŠ›å‡ºå¼‚å¸¸
      mockCreditService.createSubscription = vi.fn(() => {
        throw new Error('Subscription creation failed')
      })

      const eventData = {
        id: 'sub_paid_err',
        subscription_id: 'sub_paid_err_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-paid-err',
          plan_tier: 'basic',
          billing_cycle: 'yearly',
        },
        object: 'subscription',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('subscription.paid', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('Webhook processing failed')
    })
  })

  // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šsubscription.expired äº‹ä»¶æµ‹è¯•ï¼ˆç§¯åˆ†è§£å†»é€»è¾‘ï¼‰
  describe('subscription.expired äº‹ä»¶ï¼ˆç§¯åˆ†è§£å†»ï¼‰', () => {
    // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šå°†mockServiceClientæå‡åˆ°describeçº§åˆ«ï¼Œè®©æµ‹è¯•ç”¨ä¾‹å¯ä»¥è®¿é—®
    let mockServiceClient: any

    beforeEach(() => {
      // ðŸ”¥ Mock Service Role Client
      mockServiceClient = {
        from: vi.fn((tableName: string) => {
          if (tableName === 'user_subscriptions') {
            return {
              update: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({ error: null })),
              })),
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  single: vi.fn(() => Promise.resolve({
                    data: { user_id: 'user-expired' },
                    error: null,
                  })),
                })),
              })),
            }
          } else if (tableName === 'credit_transactions') {
            // ðŸ”¥ è€çŽ‹ä¿®å¤ï¼šMock å†»ç»“çš„ç§¯åˆ†åŒ…ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨ .select().eq().eq()
            return {
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  // ðŸ”¥ æ”¯æŒç¬¬äºŒä¸ª .eq() è°ƒç”¨
                  eq: vi.fn(() => Promise.resolve({
                    data: [
                      {
                        id: 'frozen-pkg-123',
                        amount: 500,
                        remaining_amount: 300,
                        expires_at: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString(),
                        frozen_until: new Date(Date.now() - 1000).toISOString(),  // å·²åˆ°è§£å†»æ—¶é—´
                        frozen_remaining_seconds: 86400,
                        original_expires_at: new Date().toISOString(),
                        is_frozen: true,
                      },
                    ],
                    error: null,
                  })),
                })),
              })),
              update: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({ error: null })),
              })),
            }
          }
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
            })),
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        }),
      }

      // ðŸ”¥ Mock dynamic import of createServiceClient
      vi.doMock('@/lib/supabase/service', () => ({
        createServiceClient: vi.fn(() => mockServiceClient),
      }))
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†è®¢é˜…åˆ°æœŸäº‹ä»¶å¹¶è§£å†»ç§¯åˆ†', async () => {
      const eventData = {
        id: 'sub_expired_123',
        subscription_id: 'sub_expired_456',
        customer_id: 'user-expired',
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
    })

    it('åº”è¯¥å¤„ç†æ²¡æœ‰customer_idçš„è®¢é˜…åˆ°æœŸäº‹ä»¶', async () => {
      const eventData = {
        id: 'sub_expired_no_customer',
        subscription_id: 'sub_expired_no_customer_456',
        expired_at: new Date().toISOString(),
        object: 'subscription',
        // ç¼ºå°‘ customer_id
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›žæˆåŠŸï¼ˆå‡½æ•°ä¼šä»Žè®¢é˜…è®°å½•ä¸­æŸ¥è¯¢user_idï¼‰
      expect(response.status).toBe(200)
    })

    it('åº”è¯¥å¤„ç†æŸ¥è¯¢å†»ç»“ç§¯åˆ†åŒ…å¤±è´¥çš„æƒ…å†µï¼ˆLine 681ï¼‰', async () => {
      // ðŸ”¥ ä¸´æ—¶ä¿®æ”¹mockServiceClientçš„fromæ–¹æ³•ï¼Œè®©æŸ¥è¯¢å†»ç»“åŒ…å¤±è´¥ï¼ˆè¿”å›žerrorï¼‰
      const originalFrom = mockServiceClient.from

      mockServiceClient.from = vi.fn((tableName: string) => {
        if (tableName === 'user_subscriptions') {
          // è®¢é˜…è¡¨ï¼šè¿”å›žæˆåŠŸ
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: { user_id: 'user-query-fail' },
                  error: null,
                })),
              })),
            })),
          }
        } else if (tableName === 'credit_transactions') {
          // credit_transactionsè¡¨ï¼šæŸ¥è¯¢å†»ç»“åŒ… - ðŸ”¥ è¿”å›žerrorï¼ˆè§¦å‘Line 681ï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({
                  data: null,
                  error: { message: 'Query frozen packages failed' },  // ðŸ”¥ æŸ¥è¯¢å¤±è´¥
                })),
              })),
            })),
          }
        }

        // é»˜è®¤è¿”å›ž
        return {
          select: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
          })),
        }
      })

      const eventData = {
        subscription_id: 'sub_query_fail',
        customer_id: 'user-query-fail',
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      // æ¢å¤åŽŸmock
      mockServiceClient.from = originalFrom

      // åº”è¯¥è¿”å›ž200ï¼ˆæŸ¥è¯¢å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œåªä¼šconsole.errorå¹¶returnï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })

    it('åº”è¯¥å¤„ç†è®¢é˜…åˆ°æœŸä½†æ²¡æœ‰æ‰¾åˆ°å†»ç»“ç§¯åˆ†åŒ…çš„æƒ…å†µï¼ˆLines 685-695ï¼‰', async () => {
      // ðŸ”¥ ä¸´æ—¶ä¿®æ”¹mockServiceClientçš„fromæ–¹æ³•ï¼Œè®©æŸ¥è¯¢å†»ç»“åŒ…è¿”å›žç©ºæ•°ç»„
      const originalFrom = mockServiceClient.from
      let fromCallCount = 0

      mockServiceClient.from = vi.fn((tableName: string) => {
        fromCallCount++

        if (tableName === 'user_subscriptions') {
          // è®¢é˜…è¡¨ï¼šè¿”å›žæˆåŠŸ
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: { user_id: 'user-no-frozen' },
                  error: null,
                })),
              })),
            })),
          }
        } else if (tableName === 'credit_transactions' && fromCallCount === 2) {
          // ç¬¬2æ¬¡è°ƒç”¨credit_transactionsï¼šæŸ¥è¯¢å†»ç»“åŒ… - è¿”å›žç©ºæ•°ç»„ï¼ˆè§¦å‘Lines 685-695ï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({
                  data: [],  // ðŸ”¥ æ²¡æœ‰æ‰¾åˆ°å†»ç»“çš„ç§¯åˆ†åŒ…
                  error: null,
                })),
              })),
            })),
          }
        } else if (tableName === 'credit_transactions' && fromCallCount === 3) {
          // ç¬¬3æ¬¡è°ƒç”¨credit_transactionsï¼šDebugæŸ¥è¯¢æ‰€æœ‰ç§¯åˆ†åŒ…ï¼ˆLines 688-693ï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                gt: vi.fn(() => Promise.resolve({
                  data: [{ id: 'pkg-1', amount: 100, is_frozen: false, frozen_until: null }],
                  error: null,
                })),
              })),
            })),
          }
        }

        // é»˜è®¤è¿”å›ž
        return {
          select: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
          })),
        }
      })

      const eventData = {
        subscription_id: 'sub_no_frozen',
        customer_id: 'user-no-frozen',
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      // æ¢å¤åŽŸmock
      mockServiceClient.from = originalFrom

      // åº”è¯¥è¿”å›ž200ï¼ˆæ²¡æœ‰é”™è¯¯ï¼Œåªæ˜¯æ²¡æœ‰æ‰¾åˆ°å†»ç»“åŒ…ï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })

    it('åº”è¯¥å¤„ç†è§£å†»ç§¯åˆ†åŒ…å¤±è´¥çš„æƒ…å†µï¼ˆLine 717ï¼‰', async () => {
      // ðŸ”¥ ä¸´æ—¶ä¿®æ”¹mockServiceClientçš„fromæ–¹æ³•ï¼Œè®©è§£å†»updateå¤±è´¥
      const originalFrom = mockServiceClient.from

      mockServiceClient.from = vi.fn((tableName: string) => {
        if (tableName === 'user_subscriptions') {
          // è®¢é˜…è¡¨ï¼šè¿”å›žæˆåŠŸ
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                single: vi.fn(() => Promise.resolve({
                  data: { user_id: 'user-unfreeze-fail' },
                  error: null,
                })),
              })),
            })),
          }
        } else if (tableName === 'credit_transactions') {
          // credit_transactionsè¡¨ï¼šåˆ†ä¸¤ç§è°ƒç”¨
          // ç¬¬1æ¬¡è°ƒç”¨ï¼ˆselectï¼‰ï¼šè¿”å›žå†»ç»“çš„ç§¯åˆ†åŒ…
          // ç¬¬2æ¬¡è°ƒç”¨ï¼ˆupdateï¼‰ï¼šè§£å†»å¤±è´¥
          const selectResult = {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({
                  data: [
                    {
                      id: 'frozen-pkg-fail',
                      amount: 500,
                      remaining_amount: 300,
                      expires_at: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString(),
                      frozen_until: new Date(Date.now() - 1000).toISOString(),
                      frozen_remaining_seconds: 86400,
                      original_expires_at: new Date().toISOString(),
                      is_frozen: true,
                    },
                  ],
                  error: null,
                })),
              })),
            })),
            // ðŸ”¥ updateï¼šè§£å†»å¤±è´¥ï¼Œè§¦å‘Line 717
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: { message: 'Unfreeze update failed' } })),
            })),
          }
          return selectResult
        }

        // é»˜è®¤è¿”å›ž
        return {
          select: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
          })),
        }
      })

      const eventData = {
        subscription_id: 'sub_unfreeze_fail',
        customer_id: 'user-unfreeze-fail',
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      // æ¢å¤åŽŸmock
      mockServiceClient.from = originalFrom

      // åº”è¯¥è¿”å›ž200ï¼ˆè§£å†»å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œåªä¼šconsole.errorï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })

    it('åº”è¯¥å¤„ç†æ— æ³•èŽ·å–ç”¨æˆ·IDçš„æƒ…å†µï¼ˆLine 660ï¼‰', async () => {
      const originalFrom = mockServiceClient.from

      mockServiceClient.from = vi.fn((tableName: string) => {
        if (tableName === 'user_subscriptions') {
          const callCount = vi.mocked(mockServiceClient.from).mock.calls.filter(
            (call) => call[0] === 'user_subscriptions'
          ).length

          if (callCount === 1) {
            // ç¬¬1æ¬¡è°ƒç”¨ï¼šæ›´æ–°è®¢é˜…çŠ¶æ€ä¸ºexpired - æˆåŠŸ
            return {
              update: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({ error: null })),
              })),
            }
          } else if (callCount === 2) {
            // ðŸ”¥ ç¬¬2æ¬¡è°ƒç”¨ï¼šæŸ¥è¯¢user_id - è¿”å›žnullï¼ˆè§¦å‘Line 658-660ï¼‰
            return {
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  single: vi.fn(() => Promise.resolve({
                    data: null, // æŸ¥è¯¢å¤±è´¥ï¼Œæ— æ³•èŽ·å–user_id
                    error: null,
                  })),
                })),
              })),
            }
          }
        }

        // é»˜è®¤è¿”å›ž
        return {
          update: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ error: null })),
          })),
          select: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ data: null, error: null })),
          })),
        }
      })

      const eventData = {
        id: 'sub_no_user_id',
        subscription_id: 'sub_no_user_id',
        // ðŸ”¥ å…³é”®ï¼šä¸æä¾›customer_idï¼Œå¼ºåˆ¶ä»Žæ•°æ®åº“æŸ¥è¯¢
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      mockServiceClient.from = originalFrom

      // åº”è¯¥è¿”å›ž200ï¼ˆæ— æ³•èŽ·å–user_idåªä¼šconsole.errorï¼Œä¸æŠ›å¼‚å¸¸ï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })

    it('åº”è¯¥å¤„ç†æ›´æ–°è®¢é˜…è¿‡æœŸçŠ¶æ€å¤±è´¥çš„æƒ…å†µï¼ˆLine 642ï¼‰', async () => {
      const originalFrom = mockServiceClient.from

      mockServiceClient.from = vi.fn((tableName: string) => {
        if (tableName === 'user_subscriptions') {
          // ðŸ”¥ æ›´æ–°è®¢é˜…çŠ¶æ€ä¸ºexpired - å¤±è´¥ï¼ˆè§¦å‘Line 642ï¼‰
          // ä½†ä¸é˜»æ­¢åŽç»­æµç¨‹ï¼ˆå› ä¸ºå·²ç»æœ‰customer_idï¼Œä¸éœ€è¦æŸ¥è¯¢ï¼‰
          return {
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({
                error: { message: 'Failed to update subscription status to expired' },
              })),
            })),
          }
        } else if (tableName === 'credit_transactions') {
          // MockæŸ¥è¯¢å†»ç»“åŒ… - è¿”å›žç©ºï¼ˆä¼šè§¦å‘DebugæŸ¥è¯¢ï¼‰
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({
                  data: [],
                  error: null,
                })),
                // ðŸ”¥ DebugæŸ¥è¯¢é“¾ï¼ˆLine 688-692ï¼‰ï¼šselect().eq().gt()
                gt: vi.fn(() => Promise.resolve({
                  data: [{ id: 'debug-pkg', amount: 100, is_frozen: false, frozen_until: null }],
                  error: null,
                })),
              })),
            })),
          }
        }

        // é»˜è®¤è¿”å›ž
        return {
          update: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ error: null })),
          })),
          select: vi.fn(() => ({
            eq: vi.fn(() => Promise.resolve({ data: null, error: null })),
          })),
        }
      })

      const eventData = {
        subscription_id: 'sub_update_fail',
        customer_id: 'user-update-fail', // ðŸ”¥ æä¾›customer_idï¼Œé¿å…åŽç»­æŸ¥è¯¢å¤±è´¥
        expired_at: new Date().toISOString(),
        object: 'subscription',
      }

      const request = createWebhookRequest('subscription.expired', eventData, 'valid-signature')
      const response = await POST(request)

      mockServiceClient.from = originalFrom

      // ðŸ”¥ åº”è¯¥è¿”å›ž200ï¼ˆæ›´æ–°çŠ¶æ€å¤±è´¥ä¼šconsole.errorä½†ä¼šç»§ç»­å¤„ç†è§£å†»é€»è¾‘ï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })
  })

  // ðŸ”¥ è€çŽ‹é‡æž„ï¼šupgrade/downgradeåœºæ™¯æµ‹è¯•ï¼ˆä½¿ç”¨vi.mockå…¨å±€mockï¼‰
  describe('upgrade/downgradeåœºæ™¯ï¼ˆç§¯åˆ†å†»ç»“ï¼‰', () => {
    beforeEach(() => {
      // ðŸ”¥ è€çŽ‹é‡æž„ï¼šé…ç½®mockå‡½æ•°çš„è¿”å›žå€¼ï¼ˆä½¿ç”¨vi.mockedï¼‰
      vi.mocked(handleUpgradeDowngradePrepare).mockResolvedValue({
        newSubscriptionId: 'new-sub-456',
        oldSubscriptionId: 'old-sub-123',
        fifoPackage: {
          id: 'fifo-pkg-123',
          amount: 1920,
          remaining_amount: 1820,
          expires_at: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString(),
          created_at: new Date().toISOString(),
        },
      })

      vi.mocked(handleCreditFreeze).mockResolvedValue({
        frozen: true,
        packageId: 'fifo-pkg-123',
      })
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†å‡çº§åœºæ™¯å¹¶å†»ç»“æ—§è®¢é˜…ç§¯åˆ†', async () => {
      const eventData = {
        id: 'checkout_upgrade',
        order_id: 'order_upgrade_123',
        product_id: 'prod_pro_monthly',
        subscription_id: 'sub_upgrade_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-upgrade',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
          action: 'upgrade',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)

      // ðŸ”¥ éªŒè¯upgrade/downgradeå‡½æ•°è¢«è°ƒç”¨
      expect(handleUpgradeDowngradePrepare).toHaveBeenCalledWith(
        expect.anything(), // supabaseService
        expect.anything(), // creditService
        expect.objectContaining({
          userId: 'user-upgrade',
          planTier: 'pro',
          billingCycle: 'monthly',
          action: 'upgrade',
        })
      )

      expect(handleCreditFreeze).toHaveBeenCalledWith(
        expect.anything(), // supabaseService
        expect.objectContaining({
          newSubscriptionId: 'new-sub-456',
          oldSubscriptionId: 'old-sub-123',
        }),
        'upgrade',
        'pro',
        'monthly'
      )

      // åº”è¯¥å……å€¼æ–°ç§¯åˆ†
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalled()
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†é™çº§åœºæ™¯å¹¶å†»ç»“æ—§è®¢é˜…ç§¯åˆ†', async () => {
      vi.clearAllMocks()

      // ðŸ”¥ é‡æ–°é…ç½®mockï¼ˆé™çº§åœºæ™¯ï¼‰
      vi.mocked(handleUpgradeDowngradePrepare).mockResolvedValue({
        newSubscriptionId: 'new-sub-789',
        oldSubscriptionId: 'old-sub-456',
        fifoPackage: {
          id: 'fifo-pkg-456',
          amount: 7200,
          remaining_amount: 6500,
          expires_at: new Date(Date.now() + 300 * 24 * 60 * 60 * 1000).toISOString(),
          created_at: new Date().toISOString(),
        },
      })

      vi.mocked(handleCreditFreeze).mockResolvedValue({
        frozen: true,
        packageId: 'fifo-pkg-456',
      })

      const eventData = {
        id: 'checkout_downgrade',
        order_id: 'order_downgrade_123',
        product_id: 'prod_basic_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-downgrade',
          plan_tier: 'basic',
          billing_cycle: 'monthly',
          action: 'downgrade',
          adjustment_mode: 'immediate',
          remaining_days: '15',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)

      // ðŸ”¥ éªŒè¯é™çº§åœºæ™¯çš„å‡½æ•°è°ƒç”¨
      expect(handleUpgradeDowngradePrepare).toHaveBeenCalledWith(
        expect.anything(),
        expect.anything(),
        expect.objectContaining({
          userId: 'user-downgrade',
          planTier: 'basic',
          action: 'downgrade',
        })
      )

      expect(handleCreditFreeze).toHaveBeenCalledWith(
        expect.anything(),
        expect.objectContaining({
          newSubscriptionId: 'new-sub-789',
        }),
        'downgrade',
        'basic',
        'monthly'
      )

      // åº”è¯¥å……å€¼æ–°ç§¯åˆ†ï¼ˆé™çº§åˆ°basicæœˆä»˜ï¼Œ100ç§¯åˆ†ï¼‰
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalledWith(
        'user-downgrade',
        'new-sub-789',
        100, // basicæœˆä»˜100ç§¯åˆ†
        'basic',
        'monthly',
        true // isRenewal
      )
    })
  })

  // ðŸ”¥ è€çŽ‹é‡æž„ï¼šé™çº§ç»­è®¢åœºæ™¯ï¼ˆå–æ¶ˆdescribe.skipï¼‰
  describe('é™çº§ç»­è®¢åœºæ™¯', () => {
    beforeEach(() => {
      // ðŸ”¥ Mockï¼šæ²¡æœ‰upgrade/downgradeé€»è¾‘ï¼ˆæ™®é€šç»­è®¢ï¼‰
      vi.mocked(handleUpgradeDowngradePrepare).mockClear()
      vi.mocked(handleCreditFreeze).mockClear()
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†é™çº§ç»­è®¢å¹¶æ¸…é™¤é™çº§å­—æ®µ', async () => {
      const eventData = {
        id: 'checkout_downgrade_renewal',
        order_id: 'order_renewal_123',
        product_id: 'prod_basic_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-renewal',
          plan_tier: 'basic',
          billing_cycle: 'monthly',
          // ðŸ”¥ æ²¡æœ‰actionå­—æ®µï¼Œè¯´æ˜Žæ˜¯æ™®é€šç»­è®¢
          was_downgraded: 'true', // ä½†æœ‰was_downgradedæ ‡è®°
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)

      // ðŸ”¥ éªŒè¯ï¼šä¸åº”è°ƒç”¨upgrade/downgradeé€»è¾‘
      expect(handleUpgradeDowngradePrepare).not.toHaveBeenCalled()
      expect(handleCreditFreeze).not.toHaveBeenCalled()

      // åº”è¯¥æ­£å¸¸å……å€¼ï¼ˆç»­è®¢é€»è¾‘ï¼‰
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalled()
    })
  })

  // ðŸ”¥ è€çŽ‹é‡æž„ï¼šé‡å¤å……å€¼é˜²æŠ¤ï¼ˆå–æ¶ˆdescribe.skipï¼‰
  describe('é‡å¤å……å€¼é˜²æŠ¤', () => {
    it('åº”è¯¥è·³è¿‡5åˆ†é’Ÿå†…çš„é‡å¤å……å€¼è¯·æ±‚', async () => {
      vi.clearAllMocks()

      const eventData = {
        id: 'checkout_duplicate',
        order_id: 'order_duplicate_123',
        product_id: 'prod_pro_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-duplicate',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      // ðŸ”¥ Mock: refillSubscriptionCreditsåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ·»åŠ è¿‡è®°å½•ï¼Œç¬¬äºŒæ¬¡è·³è¿‡
      let callCount = 0
      mockCreditService.refillSubscriptionCredits.mockImplementation(async () => {
        callCount++
        if (callCount === 1) {
          return undefined // ç¬¬ä¸€æ¬¡æˆåŠŸ
        } else {
          // ç¬¬äºŒæ¬¡åº”è¯¥è¢«è·³è¿‡ï¼ˆç”±äºŽ5åˆ†é’Ÿå†…é‡å¤ï¼‰
          throw new Error('åº”è¯¥è¢«è·³è¿‡çš„é‡å¤å……å€¼')
        }
      })

      // ç¬¬ä¸€æ¬¡è¯·æ±‚
      const request1 = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response1 = await POST(request1)
      expect(response1.status).toBe(200)

      // ðŸ”¥ ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆ5åˆ†é’Ÿå†…ï¼‰- åº”è¯¥è¢«è·³è¿‡
      // æ³¨æ„ï¼šè¿™ä¸ªæµ‹è¯•ä¾èµ–äºŽä¸šåŠ¡é€»è¾‘ä¸­çš„é‡å¤é˜²æŠ¤ï¼Œéœ€è¦ç¡®è®¤å®žçŽ°
      const request2 = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response2 = await POST(request2)
      expect(response2.status).toBe(200)

      // ðŸ”¥ éªŒè¯ï¼šrefillSubscriptionCreditsåº”è¯¥åªè¢«è°ƒç”¨ä¸€æ¬¡ï¼ˆç¬¬äºŒæ¬¡è¢«è·³è¿‡ï¼‰
      // æ³¨æ„ï¼šè¿™ä¸ªæ–­è¨€ä¾èµ–äºŽä¸šåŠ¡é€»è¾‘çš„å®žçŽ°ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalledTimes(1)
    })
  })

  // ðŸ”¥ åˆ é™¤æ—§çš„mockServiceClientç›¸å…³ä»£ç ï¼ˆå·²ç»ä¸éœ€è¦äº†ï¼‰
  // ä»¥ä¸‹ä»£ç è¢«åˆ é™¤ï¼š
  /*
  const mockServiceClient = {
        rpc: vi.fn((funcName: string) => {
          if (funcName === 'get_user_active_subscription') {
            return Promise.resolve({
              data: [
                {
                  id: 'old-sub-id-123',
                  plan_tier: 'basic',
                  billing_cycle: 'monthly',
                  expires_at: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString(),
                },
              ],
              error: null,
            })
          }
          return Promise.resolve({ data: null, error: null })
        }),
        from: vi.fn((tableName: string) => {
          if (tableName === 'user_subscriptions') {
            return {
              update: vi.fn(() => ({
                eq: vi.fn(() => ({
                  eq: vi.fn(() => Promise.resolve({ error: null })),
                })),
              })),
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  single: vi.fn(() => Promise.resolve({
                    data: {
                      id: 'new-sub-id-456',
                      expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                    },
                    error: null,
                  })),
                })),
              })),
            }
          } else if (tableName === 'credit_transactions') {
            return {
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  eq: vi.fn(() => ({
                    eq: vi.fn(() => ({
                      gt: vi.fn(() => ({
                        gt: vi.fn(() => ({
                          or: vi.fn(() => ({
                            order: vi.fn(() => ({
                              limit: vi.fn(() => Promise.resolve({
                                data: [
                                  {
                                    id: 'fifo-pkg-123',
                                    amount: 100,
                                    remaining_amount: 50,
                                    expires_at: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString(),
                                  },
                                ],
                                error: null,
                              })),
                            })),
                          })),
                        })),
                      })),
                    })),
                  })),
                })),
              })),
              update: vi.fn(() => ({
                eq: vi.fn(() => Promise.resolve({ error: null })),
              })),
            }
          }
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
            })),
            update: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ error: null })),
            })),
          }
        }),
      }

      // ðŸ”¥ Mock dynamic import of createServiceClient
      vi.doMock('@/lib/supabase/service', () => ({
        createServiceClient: vi.fn(() => mockServiceClient),
      }))
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†å‡çº§åœºæ™¯å¹¶å†»ç»“æ—§è®¢é˜…ç§¯åˆ†', async () => {
      const eventData = {
        id: 'checkout_upgrade',
        order_id: 'order_upgrade_123',
        product_id: 'prod_pro_monthly',
        subscription_id: 'sub_upgrade_456',
        metadata: {
          type: 'subscription',
          user_id: 'user-upgrade',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
          action: 'upgrade',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥åˆ›å»ºæ–°è®¢é˜…
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
      // åº”è¯¥å……å€¼æ–°ç§¯åˆ†
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalled()
    })

    it('åº”è¯¥æˆåŠŸå¤„ç†é™çº§åœºæ™¯å¹¶å†»ç»“æ—§è®¢é˜…ç§¯åˆ†', async () => {
      vi.clearAllMocks()

      const eventData = {
        id: 'checkout_downgrade',
        order_id: 'order_downgrade_123',
        product_id: 'prod_basic_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-downgrade',
          plan_tier: 'basic',
          billing_cycle: 'monthly',
          action: 'downgrade',
          adjustment_mode: 'immediate',
          remaining_days: '15',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥åˆ›å»ºæ–°è®¢é˜…
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
      // åº”è¯¥å……å€¼æ–°ç§¯åˆ†ï¼ˆé™çº§åˆ°basicæœˆä»˜ï¼Œ100ç§¯åˆ†ï¼‰
      expect(mockCreditService.refillSubscriptionCredits).toHaveBeenCalledWith(
        'user-downgrade',
        'sub-123',
        100,
        'basic',
        'monthly',
        false  // ðŸ”¥ isRenewal=falseï¼Œå› ä¸ºæ˜¯é™çº§æ“ä½œ
      )
    })
  })

  // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šé™çº§ç»­è®¢åœºæ™¯æµ‹è¯•
  // ðŸ”¥ TODOï¼šç”±äºŽvi.doMock()çš„é™åˆ¶ï¼Œè¿™äº›æµ‹è¯•æš‚æ—¶skip
  describe.skip('é™çº§ç»­è®¢åœºæ™¯', () => {
    it('åº”è¯¥æˆåŠŸå¤„ç†é™çº§ç»­è®¢å¹¶æ¸…é™¤é™çº§å­—æ®µ', async () => {
      const eventData = {
        id: 'checkout_renew_downgrade',
        order_id: 'order_renew',
        product_id: 'prod_basic_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-renew-downgrade',
          plan_tier: 'basic',
          billing_cycle: 'monthly',
          action: 'renew',
          was_downgraded: 'true',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥åˆ›å»ºæ–°è®¢é˜…
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
      // åº”è¯¥æ¸…é™¤é™çº§å­—æ®µï¼ˆé€šè¿‡updateè°ƒç”¨ï¼‰
      expect(mockSupabase.from).toHaveBeenCalledWith('user_subscriptions')
    })
  })

  // ðŸ”¥ è€çŽ‹æ–°å¢žï¼šé‡å¤å……å€¼é˜²æŠ¤æµ‹è¯•
  // ðŸ”¥ TODOï¼šç”±äºŽvi.doMock()çš„é™åˆ¶ï¼Œè¿™äº›æµ‹è¯•æš‚æ—¶skip
  describe.skip('é‡å¤å……å€¼é˜²æŠ¤', () => {
    beforeEach(() => {
      // ðŸ”¥ Mock Service Role Clientï¼Œæ¨¡æ‹Ÿå·²æœ‰å……å€¼è®°å½•
      const mockServiceClient = {
        from: vi.fn((tableName: string) => {
          if (tableName === 'credit_transactions') {
            return {
              select: vi.fn(() => ({
                eq: vi.fn(() => ({
                  eq: vi.fn(() => ({
                    eq: vi.fn(() => ({
                      eq: vi.fn(() => ({
                        gte: vi.fn(() => ({
                          or: vi.fn(() => ({
                            limit: vi.fn(() => Promise.resolve({
                              data: [
                                {
                                  id: 'existing-refill-123',  // å·²å­˜åœ¨çš„å……å€¼è®°å½•
                                },
                              ],
                              error: null,
                            })),
                          })),
                        })),
                      })),
                    })),
                  })),
                })),
              })),
            }
          }
          return {
            select: vi.fn(() => ({
              eq: vi.fn(() => Promise.resolve({ data: [], error: null })),
            })),
          }
        }),
      }

      vi.doMock('@/lib/supabase/service', () => ({
        createServiceClient: vi.fn(() => mockServiceClient),
      }))
    })

    it('åº”è¯¥è·³è¿‡5åˆ†é’Ÿå†…çš„é‡å¤å……å€¼è¯·æ±‚', async () => {
      vi.clearAllMocks()

      const eventData = {
        id: 'checkout_duplicate',
        order_id: 'order_duplicate',
        product_id: 'prod_pro_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-duplicate',
          plan_tier: 'pro',
          billing_cycle: 'monthly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      expect(response.status).toBe(200)
      // åº”è¯¥åˆ›å»ºè®¢é˜…
      expect(mockCreditService.createSubscription).toHaveBeenCalled()
      // ðŸ”¥ ä½†ä¸åº”è¯¥å……å€¼ç§¯åˆ†ï¼ˆå› ä¸ºæ£€æµ‹åˆ°é‡å¤ï¼‰
      // æ³¨æ„ï¼šç”±äºŽmockçš„å¤æ‚æ€§ï¼Œè¿™ä¸ªæ–­è¨€å¯èƒ½éœ€è¦è°ƒæ•´
    })
  })

  describe('æœªçŸ¥äº‹ä»¶ç±»åž‹å¤„ç†', () => {
    it('åº”è¯¥å¤„ç†æœªçŸ¥äº‹ä»¶ç±»åž‹ï¼ˆdefault caseï¼‰', async () => {
      vi.clearAllMocks()

      const eventData = {
        id: 'evt_unknown',
        some_field: 'some_value',
        object: 'unknown',
      }

      const request = createWebhookRequest('unknown.event.type', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž200ï¼ˆæœªçŸ¥äº‹ä»¶ä¸è§†ä¸ºé”™è¯¯ï¼‰
      expect(response.status).toBe(200)
      expect(await response.json()).toEqual({ received: true })
    })
  })

  describe('handleCheckoutCompleted é”™è¯¯å¤„ç†', () => {
    it('åº”è¯¥å¤„ç†handleCheckoutCompletedä¸­çš„å¼‚å¸¸å¹¶æŠ›å‡ºé”™è¯¯', async () => {
      vi.clearAllMocks()

      // Mock createSubscriptionæŠ›å‡ºå¼‚å¸¸
      mockCreditService.createSubscription = vi.fn(() => {
        throw new Error('Subscription creation failed in checkout')
      })

      const eventData = {
        id: 'checkout_error',
        order_id: 'order_error_123',
        product_id: 'prod_basic_monthly',
        metadata: {
          type: 'subscription',
          user_id: 'user-checkout-error',
          plan_tier: 'basic',
          billing_cycle: 'monthly',
        },
        object: 'checkout',
        created_at: new Date().toISOString(),
      }

      const request = createWebhookRequest('checkout.completed', eventData, 'valid-signature')
      const response = await POST(request)

      // åº”è¯¥è¿”å›ž500é”™è¯¯
      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('Webhook processing failed')
    })
  })

})
